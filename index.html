<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Steam Family Library</title>
<link rel="icon" type="image/x-icon" href="icon.ico">

<style>
  :root{
    --bg:#0b1218;
    --panel:#111a24;
    --muted:#8fa3b7;
    --accent:#1b8ad1;
    --card-radius:12px;
    --card-gap:18px;
    --card-size:180px;
    --avatar-placeholder: #223;
  }
  html,body{margin:0;font-family:Inter, system-ui;background:var(--bg);color:#e6eef6;}

  header{display:flex;align-items:center;gap:16px;padding:20px 28px;border-bottom:1px solid rgba(255,255,255,0.04);}
  .logo{display:flex;gap:12px;align-items:center;}
  .logo .mark{width:44px;height:44px;border-radius:8px;background:linear-gradient(180deg,var(--accent),#0b67a4);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;color:white;}
  h1{margin:0;font-size:18px;font-weight:600;}

  main{padding:28px;max-width:1250px;margin:0 auto;}

  .slider-container{margin-bottom:20px;display:flex;align-items:center;gap:15px;}
  .slider-container span{font-size:14px;color:var(--muted);}

  .grid{display:grid;grid-template-columns: repeat(auto-fill, minmax(var(--card-size), 1fr));gap:var(--card-gap);}

  .game-card{background:rgba(255,255,255,0.03);border-radius:var(--card-radius);padding:8px;position:relative;transition:transform .12s, box-shadow .12s;cursor:pointer;}
  .game-card:hover{transform:translateY(-6px);box-shadow:0 10px 30px rgba(2,8,20,0.6);}

  .poster{width:100%;aspect-ratio:2/3;border-radius:10px;overflow:hidden;}
  .poster img{width:100%;height:100%;object-fit:cover;display:block;}

  .meta{text-align:center;padding:10px 6px 14px;}
  .name{font-weight:600;font-size:14px;margin-bottom:8px;}
  .copies{font-size:13px;color:var(--muted);}

  .toolbox{position:absolute;left:10px;right:10px;bottom:12px;background:rgba(8,12,18,0.9);padding:8px;border-radius:10px;opacity:0;pointer-events:none;transform:translateY(10px);transition:.12s;display:flex;gap:8px;flex-wrap:wrap;}
  .game-card:hover .toolbox{opacity:1;pointer-events:auto;transform:translateY(0);}

  .owner{display:flex;gap:8px;align-items:center;}
  .owner img{width:34px;height:34px;border-radius:50%;object-fit:cover;background:var(--avatar-placeholder);}
  .o-name{font-size:13px;max-width:90px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

  .loader,.error{text-align:center;padding:20px;}
  .error{color:#ffb4b4;}
</style>
</head>

<body>
<header>
  <div class="logo">
    <div class="mark">SF</div>
    <h1>Steam Family Library</h1>
  </div>
</header>

<main>

  <input id="searchBar" type="text" placeholder="Rechercher un jeu..."
    style="width:100%;padding:10px;margin-bottom:15px;border-radius:8px;border:none;background:#111a24;color:white;">

  <div class="slider-container">
    <span>Taille :</span>
    <input type="range" id="sizeSlider" min="140" max="260" value="180">
  </div>

  <select id="sortSelect"
    style="padding:10px;margin-bottom:20px;border-radius:8px;background:#111a24;color:white;border:none;">
    <option value="az">A → Z</option>
    <option value="za">Z → A</option>
    <option value="copiesAsc">Copies ↑</option>
    <option value="copiesDesc">Copies ↓</option>
  </select>

  <div id="loader" class="loader">Chargement…</div>
  <div id="error" class="error" style="display:none;"></div>
  <div id="grid" class="grid" style="display:none;"></div>
</main>

<script>
/* ---------------- CONFIG ---------------- */
const STEAM_IDS = [
  "76561199797208434",
  "76561199428937867",
  "76561199208559725",
  "76561198342426856",
  "76561199683287336",
  "76561198788807590"
];

const BASE = "https://steam-family.onrender.com/api";
let EXCLUSIONS = [];        // chargé depuis exclusions.json
let cachedCards = [];       // { card, appid, name }
let displayedSet = new Set(); // pour éviter doublons

/* ------------- localStorage helpers ------------- */
function loadFromCache() {
  try {
    const s = localStorage.getItem("steamFamilyCache");
    return s ? JSON.parse(s) : null;
  } catch { return null; }
}
function saveToCache(data) {
  localStorage.setItem("steamFamilyCache", JSON.stringify(data));
}

/* sameData: compare arrays of objects {appid,name,owners(array)} */
function sameData(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  // compare sorted by appid
  const sa = [...a].sort((x,y)=> (x.appid - y.appid));
  const sb = [...b].sort((x,y)=> (x.appid - y.appid));
  for (let i=0;i<sa.length;i++) {
    if (sa[i].appid !== sb[i].appid) return false;
    if (sa[i].name !== sb[i].name) return false;
    // owners arrays: compare lengths then sorted elements
    const oa = (sa[i].owners || []).slice().map(String).sort();
    const ob = (sb[i].owners || []).slice().map(String).sort();
    if (oa.length !== ob.length) return false;
    for (let j=0;j<oa.length;j++) if (oa[j] !== ob[j]) return false;
  }
  return true;
}

/* ------------- UI helpers ------------- */
function createOwnerElement(personaname, avatarUrl) {
  const owner = document.createElement("div");
  owner.className = "owner";
  const img = document.createElement("img");
  img.src = avatarUrl || "";
  img.alt = personaname || "";
  const nm = document.createElement("div");
  nm.className = "o-name";
  nm.textContent = personaname || "";
  owner.appendChild(img);
  owner.appendChild(nm);
  return owner;
}

/* ------------- Filters / Sort / Slider ------------- */
function applyFilters() {
  const search = document.getElementById("searchBar").value.toLowerCase();
  cachedCards.forEach(({card, appid, name}) => {
    const excluded = EXCLUSIONS.includes(appid);
    const matches = name.toLowerCase().includes(search);
    card.style.display = (!excluded && matches) ? "block" : "none";
  });
}

function applySort() {
  const value = document.getElementById("sortSelect").value;
  const grid = document.getElementById("grid");
  const cards = Array.from(grid.children);
  cards.sort((a,b)=>{
    const nameA = a.querySelector(".name").textContent.toLowerCase();
    const nameB = b.querySelector(".name").textContent.toLowerCase();
    const copiesA = parseInt(a.querySelector(".copies").textContent) || 0;
    const copiesB = parseInt(b.querySelector(".copies").textContent) || 0;
    switch(value){
      case "az": return nameA.localeCompare(nameB);
      case "za": return nameB.localeCompare(nameA);
      case "copiesAsc": return copiesA - copiesB;
      case "copiesDesc": return copiesB - copiesA;
    }
  });
  cards.forEach(c=> grid.appendChild(c));
}

document.getElementById("sizeSlider").addEventListener("input", e=>{
  document.documentElement.style.setProperty("--card-size", e.target.value + "px");
});
document.getElementById("searchBar").addEventListener("input", ()=>{ applyFilters(); applySort(); });
document.getElementById("sortSelect").addEventListener("change", ()=>{ applyFilters(); applySort(); });

/* ------------- Main flow ------------- */
(async ()=>{

  const loader = document.getElementById("loader");
  const error  = document.getElementById("error");
  const grid   = document.getElementById("grid");

  // 1) load exclusions.json first
  try {
    const exRes = await fetch("exclusions.json");
    EXCLUSIONS = await exRes.json();
    if (!Array.isArray(EXCLUSIONS)) EXCLUSIONS = [];
  } catch(e) {
    console.error("Erreur exclusions.json:", e);
    EXCLUSIONS = [];
  }

  // 2) try to load cache
  let cached = loadFromCache();
  if (cached && Array.isArray(cached)) {
    // ensure numbers
    cached = cached.map(it => ({ appid: Number(it.appid), name: it.name, owners: Array.isArray(it.owners) ? it.owners.map(String) : [] }));
    // remove excluded from cache
    cached = cached.filter(item => !EXCLUSIONS.includes(item.appid));
  } else {
    cached = null;
  }

  // 3) render cache immediately (if any)
  if (cached) {
    loader.style.display = "none";
    grid.style.display = "grid";

    for (const item of cached) {
      // avoid double display
      if (displayedSet.has(Number(item.appid))) continue;
      displayedSet.add(Number(item.appid));

      const card = document.createElement("div");
      card.className = "game-card";
      card.dataset.appid = String(item.appid);

      const poster = document.createElement("div");
      poster.className = "poster";
      poster.innerHTML = `<img src="https://cdn.cloudflare.steamstatic.com/steam/apps/${item.appid}/library_600x900.jpg">`;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.innerHTML = `<div class="name">${item.name}</div><div class="copies">${(item.owners||[]).length} copies</div>`;

      const toolbox = document.createElement("div");
      toolbox.className = "toolbox";
      // populate toolbox with placeholders for owners (we'll replace with real avatars once players loaded)
      for (const ownerId of (item.owners || [])) {
        // show placeholder owner until real avatars available
        const placeholder = createOwnerElement(ownerId, "");
        toolbox.appendChild(placeholder);
      }

      card.appendChild(poster);
      card.appendChild(meta);
      card.appendChild(toolbox);
      grid.appendChild(card);

      cachedCards.push({ card, appid: Number(item.appid), name: item.name });
    }

    applyFilters();
    applySort();
  }

  // 4) load Steam data (players + ownedgames)
  try {
    // players
    const playersRes = await fetch(`${BASE}/players?steamids=${STEAM_IDS.join(",")}`);
    const playersJson = await playersRes.json();
    const players = (playersJson.response && playersJson.response.players) ? playersJson.response.players : [];

    const byId = {};
    players.forEach(p => byId[p.steamid] = p);

    // libs
    const libs = await Promise.all(STEAM_IDS.map(async id=>{
      const r = await fetch(`${BASE}/ownedgames?steamid=${id}`);
      const data = await r.json();
      return { id, games: data.response && data.response.games ? data.response.games : [] };
    }));

    // build combined (apply exclusions)
    const combined = new Map();
    for (const lib of libs) {
      for (const g of lib.games) {
        if (!g || !g.appid) continue;
        const appidNum = Number(g.appid);
        if (EXCLUSIONS.includes(appidNum)) continue;
        if (!combined.has(appidNum)) combined.set(appidNum, { name: g.name || ("App " + appidNum), owners: new Set() });
        combined.get(appidNum).owners.add(lib.id);
      }
    }

    // prepare final cache array with owners list (array of steamids)
    const finalArray = [];
    for (const [appid, data] of combined) {
      finalArray.push({ appid: Number(appid), name: data.name, owners: Array.from(data.owners).map(String) });
    }

    // compare & save cache if different
    const oldCache = loadFromCache();
    // normalize oldCache to same shape if present
    const normOld = oldCache ? oldCache.map(it => ({ appid: Number(it.appid), name: it.name, owners: Array.isArray(it.owners) ? it.owners.map(String) : [] })) : null;
    if (!sameData(normOld, finalArray)) {
      try { saveToCache(finalArray); console.log("Cache mis à jour"); } catch(e){ console.warn("Impossible de sauver cache:", e); }
    }

    // Now: display/update games from combined
    loader.style.display = "none";
    grid.style.display = "grid";

    for (const [appid, data] of combined) {
      const appNum = Number(appid);

      // if already displayed from cache -> update copies and toolbox
      const exists = cachedCards.find(c => Number(c.appid) === appNum);
      if (exists) {
        const card = exists.card;
        // update copies text
        const copiesEl = card.querySelector(".copies");
        if (copiesEl) copiesEl.textContent = data.owners.size + " copies";

        // rebuild toolbox with real player avatars/names (clear first)
        const toolbox = card.querySelector(".toolbox");
        if (toolbox) {
          toolbox.innerHTML = "";
          for (const ownerId of data.owners) {
            const p = byId[ownerId];
            const avatar = p ? (p.avatarfull || "") : "";
            const name = p ? (p.personaname || ownerId) : ownerId;
            toolbox.appendChild(createOwnerElement(name, avatar));
          }
        }
        // ensure cachedCards entry updated name if changed
        exists.name = data.name;
      } else {
        // not in cache -> create new card
        if (displayedSet.has(appNum)) continue; // safety
        displayedSet.add(appNum);

        const card = document.createElement("div");
        card.className = "game-card";
        card.dataset.appid = String(appNum);

        const poster = document.createElement("div");
        poster.className = "poster";
        poster.innerHTML = `<img src="https://cdn.cloudflare.steamstatic.com/steam/apps/${appNum}/library_600x900.jpg">`;

        const meta = document.createElement("div");
        meta.className = "meta";
        meta.innerHTML = `<div class="name">${data.name}</div><div class="copies">${data.owners.size} copies</div>`;

        const toolbox = document.createElement("div");
        toolbox.className = "toolbox";
        for (const ownerId of data.owners) {
          const p = byId[ownerId];
          const avatar = p ? (p.avatarfull || "") : "";
          const name = p ? (p.personaname || ownerId) : ownerId;
          toolbox.appendChild(createOwnerElement(name, avatar));
        }

        card.appendChild(poster);
        card.appendChild(meta);
        card.appendChild(toolbox);
        grid.appendChild(card);

        cachedCards.push({ card, appid: appNum, name: data.name });
      }
    }

    // final filters & sort
    applyFilters();
    applySort();

  } catch (err) {
    console.error("Erreur chargement Steam:", err);
    loader.style.display = "none";
    error.style.display = "block";
    error.textContent = "Erreur : " + String(err);
  }

})();
</script>

</body>
</html>
